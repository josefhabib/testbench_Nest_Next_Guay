import * as bcrypt from 'bcrypt';
import { Injectable, UnprocessableEntityException } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { PrismaUsersDbService } from 'src/prisma_users-db/prisma_users-db.service';
import { Prisma, PrismaClient, User } from '@prisma/client'; // ! Prisma generated types from schema.prisma file 

@Injectable()
export class UsersService {

  constructor(private readonly PrismaUsersDbService: PrismaUsersDbService){}
  
  async createUser(ctx: CreateUserDto) : Promise<Omit<User, 'password'>> { // NB: label async (access db) and add return type (NB: Don't return password! Omit utility type used to exclude password field) 
    // persist user (& return promise):
    try {
      return await this.PrismaUsersDbService.user.create({
        data: {
          ...ctx,
          password: await bcrypt.hash(ctx.password, 10)
        },
        select:{
          id: true,
          email: true
        }
      });
    } catch (error) {
      if (error.code === 'P2002') { // Prisma unique constraint violation error code
        throw new UnprocessableEntityException('A user with this email already exists.');
      }
      throw error;
    }
  }

  async getUser(filter: Prisma.UserWhereUniqueInput): Promise<User> {
    
    // ---
    // The getUser method (UsersService class) retrieves a uniquely identified user-db (using Prisma) 
    // 
    // The method accepts a single parameter, 'filter', which is of type Prisma.UserWhereUniqueInput. 
    //  ! This type is GENERATED by Prisma (based on the schmema file) and represents a unique identifier for a user, such as an email or user ID.
    //  Tip: "Go To Definition" on Prisma.UserWhereUniqueInput to see the generated type definition
    //
    // Inside the method, the PrismaUsersDbService.user.findUniqueOrThrow function is called. 
    //  This function is also provided by Prisma, and it attempts to find a single user in the database that matches the specified filter. 
    //  The where clause is used to specify the filter criteria. 
    // 
    // -> If a user matching the filter is found, the function returns the user object. 
    // -> If no user is found, or if multiple users match the filter, the function throws an error.
    // ---

    return this.PrismaUsersDbService.user.findUniqueOrThrow({
      where: filter,
    });
  }
}

// Find a user in the users-db database given SOME criteria (not hardcoded)
    // NB: Prisma allows you to use the findUniqueOrReject method to find a user by their email (or throw an error if no/multiple users are found)
    // NB: Prisma allows you to define the filter criterion in real time (i.e. through the args provided to the method) - this avoids having to define a separate query method for each filter criterion 

