import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy, ExtractJwt } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { Request } from 'express';
import { IJwtPayload } from '../../interfaces/jwt-payload.interface';


@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy, 'my-jwt-strategy') {
  constructor(private readonly configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromExtractors([
        (request: Request) => {return request.cookies['be-core-auth']} 
      ]),
      secretOrKey: configService.get('NESTJS_CORE_JWT_SECRET'),
    });
  }

  async validate(payload: IJwtPayload) {
     return { payload }; // return the payload as the user attribute of the request object
  }
}



// Implementation Note: Parsing & decoding incoming JWT tokens
// -----------------------------------------------------------
//
// Context:
//  The JwtStrategy class is a Passport strategy that is used to parse and decode incoming JWT tokens.
//  JWT tokens were generated by the @nestjs/jwt module's jwtService (see auth-e.service.ts), and 
//  attached as a (secure, http-only) cookie.
//
//  To use the jwt to authenticate subsequent incoming requests we need to parse the attached request 
//   cookie and extract the JWT token (this was done by the cookie-parser middleware (i.e. main.ts file))
//   and then decode the token to extract the payload.
// 
// Scope:
//  Here we decode the token and extract the payload using the passport-jwt module to implement the 
//   JwtStrategy class.
// 
// Steps:
//
// Part 1: Extract & decrypt the JWT token from the request
// 1. Define the JwtStrategy class that extends the PassportStrategy Factory (from @nestjs/passport) 
//      initialized using the appropriate "Strategy" class. This provides the JWT strategy-specific
//      APPLICATION-AGNOSTIC functionalities.
// 2. This is complemented by APPLICATION-SPECIFIC configurations are passed to the super() constructor 
//      of the JwtStrategy class:
//      - jwtFromRequest: this is used to extract the JWT token from the request.
//      - secretOrKey: this is used to decode the JWT token.
//
// 3. Access the (encrypted) JWT (jwtFromRequest)
//     
//     The afrementioned cookie-parser middleware (main.ts) parsed the incoming request (incl. cookies) and generated
//     the request OBJECT. 
//
//     To access the auth token we use the ExtractJwt.fromExtractors(). 
// 
//        Side note: ExtractJwt.fromExtractors()
//         The reason we need this method (rather than simply accessing the corresponding attribute directly) is that 
//         the fromExtrators() method provides a flexible and modular way to define how the JWT should be extracted.
//         The benefit of this approach (over direct access) is that it allows us to:
//         - flexibility: easily switch between different extraction methods (e.g. extracting from headers, query parameters, etc.) 
//         - modularity: allows us to define multiple extractors in a clean and modular way (i.e. without affecting the core logic)
//         - reusability: allows us to reuse the extraction logic in different parts of the application.
//         - testability: allows us to easily test the extraction logic in isolation.
//         - separation of concerns: separates the extraction logic from the core logic, making the code easier to understand and maintain.
//         - error handling: provides a clean and consistent way to handle errors that may occur during extraction. 
// 
//     The fromExtractors() method is passed a function that extracts the token from the request object.
//
// Part 2: validate()
// Every passport strategy must implement a validate() method. This method is called by Passport after the token has been extracted and decrypted.
// The validate() method is passed the decrypted payload of the JWT token. This payload is then used to authenticate the user.